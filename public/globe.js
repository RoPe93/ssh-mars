// Generated by CoffeeScript 1.8.0
(function() {
  var Globe;

  Globe = {
    loadResources: function(textures, xhr, allSucceeded) {
      var completeTextures, completeXHR, name, pendingTextures, pendingXHR, success, textureLoader, url, xhrLoader, _results;
      pendingTextures = textures;
      pendingXHR = xhr;
      completeTextures = {};
      completeXHR = {};
      success = function(pending, complete, name) {
        return function(result) {
          delete pending[name];
          complete[name] = result;
          if (Object.keys(pendingTextures).length === 0 && Object.keys(pendingXHR).length === 0) {
            return allSucceeded(completeTextures, completeXHR);
          }
        };
      };
      textureLoader = new THREE.TextureLoader();
      for (name in pendingTextures) {
        url = pendingTextures[name];
        textureLoader.load(url, success(pendingTextures, completeTextures, name));
      }
      xhrLoader = new THREE.XHRLoader();
      _results = [];
      for (name in pendingXHR) {
        url = pendingXHR[name];
        _results.push(xhrLoader.load(url, success(pendingXHR, completeXHR, name)));
      }
      return _results;
    },
    loadEverything: function(success) {
      var textures, xhr;
      textures = {
        surface: 'mars_filtered_2500.jpg',
        bump: 'mars_elevation_2500.jpg',
        pinHead: 'circle.png',
        pinHeadMine: 'circle_b.png'
      };
      xhr = {
        pins: 'pins.csv'
      };
      return Globe.loadResources(textures, xhr, success);
    },
    init: function(container, textures, xhr) {
      var globe;
      globe = {
        interaction: {
          mouse: Globe.vec2(0, 0),
          targetRotation: Globe.vec2(Math.PI * 5 / 16, Math.PI * 1 / 12),
          rotation: Globe.vec2(Math.PI * (5 / 16 - 1), 0),
          distance: 10000
        },
        gl: Globe.setupScene(800, 800, textures),
        container: container
      };
      globe.container.appendChild(globe.gl.renderer.domElement);
      Globe.addEvents(globe, globe.interaction, globe.gl, globe.container);
      Globe.animate(function() {
        return Globe.render(globe.gl, globe.interaction);
      });
      Globe.populatePins(globe.gl, xhr.pins);
      return globe;
    },
    eventModes: {
      rest: [['container', 'mousemove', 'mouseMove'], ['container', 'mousedown', 'dragStart']],
      dragging: [['document', 'mousemove', 'dragMove'], ['document', 'mouseup', 'dragStop'], ['document', 'mouseexit', 'dragStop']],
      hoveringWithPin: []
    },
    addEvents: function(globe) {
      globe.interaction.events = {
        mouseMove: function(e) {
          var pin;
          pin = Globe.raycastPin(globe.gl, Globe.containerOffset(globe.container, e));
          if (pin != null) {
            if (pin.fingerprint === Globe.myFingerprint()) {
              return Globe.setCaption('My fingerprint: ' + pin.fingerprint);
            } else {
              return Globe.setCaption('Pin placed by: ' + pin.fingerprint);
            }
          } else {
            return Globe.setCaption();
          }
        },
        dragStart: function(e) {
          globe.container.style.cursor = 'grabbing';
          globe.interaction.mouse = Globe.containerOffset(globe.container, e);
          caption.textContent = null;
          return Globe.transitionMode(globe, 'dragging');
        },
        dragMove: function(e) {
          var ds, prevMouse;
          prevMouse = globe.interaction.mouse;
          globe.interaction.mouse = Globe.containerOffset(globe.container, e);
          ds = globe.interaction.mouse.clone().sub(prevMouse).multiply(Globe.vec2(-1, 1));
          globe.interaction.targetRotation.add(ds.multiplyScalar(0.004));
          return globe.interaction.targetRotation.setY(Globe.clamp([-Math.PI / 2, Math.PI / 2], globe.interaction.targetRotation.y));
        },
        dragStop: function(e) {
          globe.container.style.cursor = null;
          return Globe.transitionMode(globe, 'rest');
        }
      };
      return Globe.transitionMode(globe, 'rest');
    },
    transitionMode: function(globe, mode) {
      var binding, targets, _i, _j, _len, _len1, _ref, _ref1;
      targets = {
        container: globe.container,
        document: document
      };
      if (globe.interaction.mode != null) {
        _ref = Globe.eventModes[globe.interaction.mode];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          binding = _ref[_i];
          targets[binding[0]].removeEventListener(binding[1], globe.interaction.events[binding[2]]);
        }
      }
      _ref1 = Globe.eventModes[mode];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        binding = _ref1[_j];
        targets[binding[0]].addEventListener(binding[1], globe.interaction.events[binding[2]]);
      }
      return globe.interaction.mode = mode;
    },
    setCaption: function(text) {
      var caption;
      caption = document.getElementById('caption');
      return caption.textContent = text;
    },
    setupScene: function(w, h, textures) {
      var geometry, gl, material;
      gl = {
        scene: new THREE.Scene(),
        camera: new THREE.PerspectiveCamera(30, w / h, 1, 10000),
        renderer: new THREE.WebGLRenderer(),
        textures: textures,
        pinTemplate: {
          line: new THREE.Line(new THREE.Geometry(), new THREE.LineBasicMaterial({
            color: 0xffffff,
            opacity: 1
          })),
          sprite: new THREE.Sprite(new THREE.SpriteMaterial({
            color: 0xffffff
          }))
        },
        pins: new THREE.Object3D()
      };
      gl.renderer.setSize(w, h);
      gl.pinTemplate.line.geometry.vertices = [Globe.vec3(0, 0, 0), Globe.vec3(0, 0, 0)];
      gl.pinTemplate.sprite.scale.set(3, 3, 0);
      gl.pinTemplate.sprite.material.map = gl.textures.pinHead;
      gl.pins.fingerprints = {};
      material = new THREE.MeshPhongMaterial({
        map: gl.textures.surface,
        bumpMap: gl.textures.bump,
        color: 0xffffff,
        ambient: 0xffffff,
        specular: 0x9c521d,
        shininess: 1,
        bumpScale: 4,
        shading: THREE.SmoothShading
      });
      geometry = new THREE.SphereGeometry(200, 40, 30);
      gl.mesh = new THREE.Mesh(geometry, material);
      gl.scene.add(gl.mesh);
      gl.lights = {
        ambient: new THREE.AmbientLight(0x222222),
        directional: new THREE.DirectionalLight(0xffffff, 1)
      };
      gl.lights.directional.position.set(1, 0, 1).normalize();
      gl.scene.add(gl.lights.ambient, gl.lights.directional, gl.pins);
      return gl;
    },
    makePin: function(gl, mine) {
      var pin;
      pin = new THREE.Object3D();
      pin.line = gl.pinTemplate.line.clone();
      pin.line.geometry = gl.pinTemplate.line.geometry.clone();
      pin.sprite = gl.pinTemplate.sprite.clone();
      pin.sprite.material = gl.pinTemplate.sprite.material.clone();
      if (mine) {
        pin.sprite.material.map = gl.textures.pinHeadMine;
        pin.sprite.scale.set(5, 5, 0);
      }
      return pin.add(pin.line, pin.sprite);
    },
    positionPin: function(gl, pin, pos) {
      var verts;
      verts = pin.line.geometry.vertices;
      verts[0].copy(Globe.vec3(0, 0, 0));
      verts[1].copy(pos.normalize().multiplyScalar(8));
      pin.line.geometry.verticesNeedUpdate = true;
      pin.sprite.position.copy(pos.normalize().multiplyScalar(9));
      return pin.position.copy(pos.normalize().multiplyScalar(200));
    },
    animate: function(render) {
      requestAnimationFrame(function() {
        return Globe.animate(render);
      });
      return render();
    },
    render: function(gl, i) {
      var axis;
      i.rotation.add(i.targetRotation.clone().sub(i.rotation).multiplyScalar(0.05));
      i.distance += (850 - i.distance) * 0.2;
      axis = Globe.vec3(0, 1, 0);
      gl.camera.position.copy(Globe.vec3(0, 0, 1).applyAxisAngle(axis, i.rotation.x).multiplyScalar(Math.cos(i.rotation.y)).setY(Math.sin(i.rotation.y)).multiplyScalar(i.distance));
      gl.lights.directional.position.copy(gl.camera.position.clone().applyAxisAngle(axis, Math.PI / 4).normalize());
      gl.camera.lookAt(Globe.vec3(0, 0, 0));
      return gl.renderer.render(gl.scene, gl.camera);
    },
    glMouse: function(mouse) {
      return mouse.clone().multiplyScalar(2 / 800).addScalar(-1).multiply(Globe.vec2(1, -1));
    },
    rayDirection: function(gl, mouse) {
      var glmouse;
      glmouse = Globe.glMouse(mouse);
      return Globe.vec3(glmouse.x, glmouse.y, 0).unproject(gl.camera).sub(gl.camera.position).normalize();
    },
    raycast: function(gl, mouse) {
      var direction, hits, raycaster;
      direction = Globe.rayDirection(gl, mouse);
      raycaster = new THREE.Raycaster();
      raycaster.set(gl.camera.position, direction);
      hits = raycaster.intersectObject(gl.mesh, false);
      if (hits.length > 0) {
        return hits[0].point;
      } else {
        return null;
      }
    },
    raycastPin: function(gl, mouse) {
      var direction, hits, objs, raycaster;
      direction = Globe.rayDirection(gl, mouse);
      raycaster = new THREE.Raycaster();
      raycaster.set(gl.camera.position, direction);
      raycaster.linePrecision = 10;
      objs = gl.pins.children.map(function(pin) {
        return pin.line;
      });
      objs.push(gl.mesh);
      hits = raycaster.intersectObjects(objs, false);
      if (hits.length > 0 && hits[0].object.type === 'Line') {
        return hits[0].object.parent;
      } else {
        return null;
      }
    },
    vectorToLatLon: function(pos) {
      return {
        lat: (Math.atan2(Math.sqrt(pos.x * pos.x + pos.z * pos.z), -pos.y) - Math.PI / 2) * 180 / Math.PI,
        lon: -Math.atan2(pos.z, pos.x) * 180 / Math.PI
      };
    },
    latLonToVector: function(lat, lon) {
      var x, y;
      x = lon * Math.PI / 180 + Math.PI / 2;
      y = lat * Math.PI / 180;
      return Globe.vec3(0, 0, 1).applyAxisAngle(Globe.vec3(0, 1, 0), x).multiplyScalar(Math.cos(y)).setY(Math.sin(y));
    },
    containerOffset: function(container, e) {
      return Globe.vec2(e.clientX - container.offsetLeft, e.clientY - container.offsetTop);
    },
    vec3: function(x, y, z) {
      return new THREE.Vector3(x, y, z);
    },
    vec2: function(x, y) {
      return new THREE.Vector2(x, y);
    },
    clamp: function(limits, x) {
      if (limits[1] < limits[0]) {
        limits = [limits[1], limits[0]];
      }
      if (x < limits[0]) {
        return limits[0];
      } else if (x > limits[1]) {
        return limits[1];
      } else {
        return x;
      }
    },
    myFingerprint: function() {
      var el;
      el = document.getElementById('my-fingerprint');
      if (el != null) {
        return el.getAttribute('value');
      } else {
        return null;
      }
    },
    populatePins: function(gl, csv) {
      var mine, myFingerprint, pin, placedMine, props, _i, _len, _ref;
      myFingerprint = Globe.myFingerprint();
      placedMine = false;
      _ref = Globe.parseCSV(csv);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        props = _ref[_i];
        mine = props.fingerprint === myFingerprint;
        if (mine) {
          placedMine = true;
        }
        pin = Globe.makePin(gl, mine);
        pin.fingerprint = props.fingerprint;
        Globe.positionPin(gl, pin, Globe.latLonToVector(props.lat, props.lon));
        gl.pins.fingerprints[pin.fingerprint] = pin;
        gl.pins.add(pin);
      }
      if (!placedMine) {
        return document.getElementById('pinwell').classList.remove('empty');
      }
    },
    get: function(path, success, error) {
      var req;
      req = new XMLHttpRequest();
      req.onload = function(e) {
        return success(req.responseText);
      };
      req.onerror = function(e) {
        return error(req);
      };
      req.open('get', path);
      return req.send();
    },
    parseCSV: function(text) {
      return text.split('\n').filter(function(line) {
        return line.length > 0;
      }).map(function(line) {
        return line.split(',');
      }).map(function(row) {
        return {
          fingerprint: row[0],
          lat: parseFloat(row[1]),
          lon: parseFloat(row[2])
        };
      });
    }
  };

  window.Globe = Globe;

}).call(this);
